//#include "movegen.hpp"
//
//
//static void Test(anka::GameState& pos, int depth)
//{
//	using namespace anka;
//
//	if (depth == -1)
//		return;
//
//	MoveList<256> all_list;
//	MoveList<64> cap_list;
//
//	all_list.GenerateLegalMoves(pos);
//	cap_list.GenerateLegalCaptures(pos);
//
//	int num_captures = 0;
//	bool fail = false;
//	for (int i = 0; i < all_list.length; i++) {
//		Move m = all_list.moves[i].move;
//		if (move::IsCapture(m)) {
//			num_captures++;
//			if (!cap_list.Find(m)) {
//				char move_str[6];
//				move::ToString(m, move_str);
//				printf("Capture move %s was not generated by capture generator.\n", move_str);
//				fail = true;
//			}
//		}
//		else {
//			if (cap_list.Find(m)) {
//				char move_str[6];
//				move::ToString(m, move_str);
//				printf("Non capture move %s was generated by capture generator.\n", move_str);
//				fail = true;
//			}
//		}
//
//		if (fail) {
//			pos.Print();
//			printf("\nAll moves list:\n");
//			all_list.PrintMoves();
//			printf("\nCapture list:\n");
//			cap_list.PrintMoves();
//			abort();
//		}
//	}
//
//	if (depth <= 0)
//		return;
//	for (int i = 0; i < all_list.length; i++) {
//		pos.MakeMove(all_list.moves[i].move);
//		Test(pos, depth - 1);
//		pos.UndoMove();
//	}
//
//
//}
//int main()
//{
//	using namespace anka;
//	constexpr u64 RNG_SEED = 719;
//
//	anka::RNG rng(RNG_SEED);
//
//	anka::InitZobristKeys(rng);
//	anka::attacks::InitAttacks();
//
//	GameState pos;
//
//	pos.LoadPosition("3N1k2/3q2bp/1p2p3/4P1Q1/8/1PP3P1/5P1P/6K1 w - - 1 33");
//	Test(pos, 5);
//	printf("SUCCESS: 3N1k2/3q2bp/1p2p3/4P1Q1/8/1PP3P1/5P1P/6K1 w - - 1 33\n");
//
//
//	pos.LoadPosition("r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq -");
//	Test(pos, 4);
//	printf("SUCCESS: r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq -\n");
//
//
//
//	return 0;
//}